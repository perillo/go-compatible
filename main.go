// Copyright 2021 Manlio Perillo. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"github.com/perillo/go-compatible/internal/invoke"
	"github.com/perillo/go-compatible/internal/version"
)

// gosdk is the path to go sdk directory, by default ~/sdk.  It can be
// overridden using the GOSDK environment variable.
var gosdk string

// Flags.
var (
	action = flag.String("mode", "vet", "verification mode (vet, build or test)")
	since  version.Version
)

type release struct {
	goroot  string
	version version.Version
}

func (r release) String() string {
	return "go" + r.version.String()
}

func init() {
	flag.Var(&since, "since", "use only releases more recent than a specific version")
}

func init() {
	if value, ok := os.LookupEnv("GOSDK"); ok {
		gosdk = value

		return
	}

	home, err := os.UserHomeDir()
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to get home directory: %v\n", err)

		return
	}
	gosdk = filepath.Join(home, "sdk")
}

func main() {
	// Setup log.
	log.SetFlags(0)

	// Parse command line.
	flag.Usage = func() {
		w := flag.CommandLine.Output()
		fmt.Fprintln(w, "Usage: go-compatible [-since goversion] [-mode mode] [packages]")
		fmt.Fprintln(w, "Options:")
		flag.PrintDefaults()
	}
	flag.Parse()
	args := flag.Args()
	switch *action {
	case "vet", "build", "test":
	default:
		const err = "must be \"vet\", \"build\" or \"test\""
		fmt.Fprintf(os.Stderr, "invalid value %q for flag -mode: %s\n", *action, err)
		flag.Usage()

		os.Exit(2)
	}

	releases, err := gosdklist(since)
	if err != nil {
		log.Fatal(err)
	}

	if err := run(releases, args, *action); err != nil {
		log.Fatal(err)
	}
}

// run invokes go vet or go test for all the specified releases.
func run(releases []release, patterns []string, action string) error {
	tool := govet
	switch action {
	case "build":
		tool = gobuild
	case "test":
		tool = gotest
	}

	nl := []byte("\n")
	index := 0 // current failed release

	for _, rel := range releases {
		msg, err := tool(rel, patterns)
		if err != nil {
			return err
		}
		if msg == nil {
			continue
		}

		// Print go vet diagnostic message or go test report
		if index > 0 {
			os.Stderr.Write(nl)
		}
		fmt.Fprintf(os.Stderr, "using go%s\n", rel.version)
		os.Stderr.Write(msg)
		os.Stderr.Write(nl)

		index++
	}

	if action == "build" {
		return goclean()
	}

	return nil
}

// gosdklist returns a list of all go releases in the sdk more recent than the
// specified version.
func gosdklist(since version.Version) ([]release, error) {
	list := make([]release, 0, 32) // preallocate memory
	files, err := os.ReadDir(gosdk)
	if err != nil {
		return nil, err
	}
	for _, file := range files {
		name := file.Name()
		if file.IsDir() && strings.HasPrefix(name, "go") {
			goroot := filepath.Join(gosdk, name)
			line, err := goversion(goroot)
			if err != nil {
				return nil, err
			}
			version, err := version.ParseLine(line)
			if err != nil {
				return nil, err
			}

			if version.Less(since) {
				continue
			}

			rel := release{
				goroot:  goroot,
				version: version,
			}
			list = append(list, rel)
		}
	}
	if len(list) == 0 {
		return nil, fmt.Errorf("no go releases found in %s", gosdk)
	}

	// Sort the releases.
	sort.Slice(list, func(i, j int) bool {
		return list[i].version.Less(list[j].version)
	})

	return list, nil
}

// goclean invokes go clean to clean the files generated by go build in the
// current directory, for versions older than go1.8.
func goclean() error {
	// Use the go command installed in the system.
	cmd := exec.Command("go", "clean")

	return invoke.Run(cmd)
}

// goversion returns the version of go from goroot.
func goversion(goroot string) (string, error) {
	gocmd := filepath.Join(goroot, "bin", "go")
	cmd := exec.Command(gocmd, "version")
	cmd.Env = append(os.Environ(), "GOROOT="+goroot)

	stdout, err := invoke.Output(cmd)
	if err != nil {
		// TODO(mperillo): Ignore the case of gocmd not found.
		return "", err
	}

	return string(stdout), nil
}

// govet invokes go vet on the packages named by the given patterns, for the
// specified release.  It returns the diagnostic message and a non nil error,
// in case of a fatal error like go command not found.
func govet(rel release, patterns []string) ([]byte, error) {
	// TODO(mperillo): go1.4 does not have the go vet tool;  report an useful
	// error if the user has not installed it.
	gocmd := filepath.Join(rel.goroot, "bin", "go")
	args := append([]string{"vet"}, patterns...)
	cmd := exec.Command(gocmd, args...)
	cmd.Env = append(os.Environ(), "GOROOT="+rel.goroot)

	if err := invoke.Run(cmd); err != nil {
		cmderr := err.(*invoke.Error)

		// Determine the error type to decide if there was a fatal problem
		// with the invocation of go vet that requires the termination of
		// the program.
		switch cmderr.Err.(type) {
		case *exec.Error:
			return nil, err
		case *exec.ExitError:
			return cmderr.Stderr, nil
		}

		return nil, err // should not be reached
	}

	return nil, nil
}

var go18 = version.Must(version.Parse("go1.8"))

// gobuild invokes go build on the packages named by the given patterns, for
// the specified release.  It returns the diagnostic message and a non nil
// error, in case of a fatal error like go command not found.
func gobuild(rel release, patterns []string) ([]byte, error) {
	gocmd := filepath.Join(rel.goroot, "bin", "go")
	var args = []string{"build"}

	if rel.version.Less(go18) {
		// Invoke `go build [packages]`.
		// It is not the default choice because, in case patterns match a
		// single main package, go build will write the generated binary in the
		// current directory.
		args = append(args, patterns...)
	} else {
		// Invoke `go build -o /dev/null [packages]`.
		// Note that this is not documented.
		args := append(args, "-o", os.DevNull)
		args = append(args, patterns...)
	}
	cmd := exec.Command(gocmd, args...)
	cmd.Env = append(os.Environ(), "GOROOT="+rel.goroot)

	if err := invoke.Run(cmd); err != nil {
		cmderr := err.(*invoke.Error)

		// Determine the error type to decide if there was a fatal problem
		// with the invocation of go build that requires the termination of
		// the program.
		switch cmderr.Err.(type) {
		case *exec.Error:
			return nil, err
		case *exec.ExitError:
			return cmderr.Stderr, nil
		}

		return nil, err // should not be reached
	}

	return nil, nil
}

// gotest invokes go test on the packages named by the given patterns, for the
// specified release.  It returns the test report and a non nil error, in case
// of a fatal error like go command not found.
//
// For older versions go test report more errors compared to go vet.
func gotest(rel release, patterns []string) ([]byte, error) {
	gocmd := filepath.Join(rel.goroot, "bin", "go")
	args := append([]string{"test"}, patterns...)
	cmd := exec.Command(gocmd, args...)
	cmd.Env = append(os.Environ(), "GOROOT="+rel.goroot)

	// go test writes the go vet diagnostic on stderr and the test report on
	// stdout.
	if data, err := cmd.CombinedOutput(); err != nil {
		// Determine the error type to decide if there was a fatal problem
		// with the invocation of go test that requires the termination of
		// the program.
		switch err.(type) {
		case *exec.Error:
			return nil, err
		case *exec.ExitError:
			return bytes.TrimSpace(data), nil
		}

		return nil, err // should not be reached
	}

	return nil, nil
}
